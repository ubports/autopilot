#!/usr/bin/env python
# -*- Mode: Python; coding: utf-8; indent-tabs-mode: nil; tab-width: 4 -*-
# Copyright 2012 Canonical
# Author: Thomi Richards
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3, as published
# by the Free Software Foundation.

from __future__ import absolute_import

from datetime import datetime
from imp import find_module
import os
import os.path
from os import remove
from platform import node
from subprocess import call
import sys
from tempfile import NamedTemporaryFile
from testtools import iterate_tests
from textwrap import dedent
from argparse import ArgumentParser
from unittest.loader import TestLoader
from unittest.runner import TextTestRunner
from unittest import TestSuite


# list autopilot depends here, with the form:
# ('python module name', 'ubuntu package name'),
DEPENDS = [
    ('compizconfig', 'python-compizconfig'),
    ('dbus', 'python-dbus'),
    ('gobject', 'python-gobject'),
    ('gtk', 'python-gtk2'),
    ('ibus', 'python-ibus'),
    ('junitxml', 'python-junitxml'),
    ('testscenarios', 'python-testscenarios'),
    ('testtools', 'python-testtools'),
    ('xdg', 'python-xdg'),
    ('Xlib', 'python-xlib'),
    ('pydot', 'python-pydot'),
]


def check_depends():
    """Check for required dependancies, and print a helpful message if any are
    missing.

    If all required modules are present, return True, False otherwise.
    """
    missing = []
    for module_name, package_name in DEPENDS:
        try:
            find_module(module_name)
        except ImportError:
            missing.append(package_name)
    if missing:
        print dedent("""\
            You are missing one or more packages required to run autopilot.
            They are:

            %s

            Please install these packages and re-run this script.
            """ % (' '.join(missing))
            )
        return False
    return True


def parse_arguments():
    """Parse command-line arguments, and return an argparse arguments
    object.
    """
    parser = ArgumentParser(description=dedent("""\
        Autopilot test tool.
        """))
    subparsers = parser.add_subparsers(help='Run modes', dest="mode")

    parser_run = subparsers.add_parser('run', help="Run autopilot tests")
    parser_run.add_argument('-o', "--output", required=False,
                            help='Write test result report to file.\
                            Defaults to stdout.\
                            If given a directory instead of a file will \
                            write to a file in that directory named: \
                            <hostname>_<dd.mm.yyy_HHMMSS>.log')
    parser_run.add_argument('-f', "--format", choices=['text', 'xml'],
                            default='text',
                            required=False,
                            help='Specify desired output format. \
                            Default is "text".')
    parser_run.add_argument('-r', '--record', action='store_true',
                            default=False, required=False,
                            help="Record failing tests. Required \
                            'recordmydesktop' app to be installed.\
                            Videos are stored in /tmp/autopilot.")
    parser_run.add_argument("-rd", "--record-directory", required=False,
                            default="/tmp/autopilot", type=str,
                            help="Directory to put recorded tests \
                            (only if -r) specified.")
    parser_run.add_argument("suite", nargs="+",
                            help="Specify test suite(s) to run.")

    parser_list = subparsers.add_parser('list', help="List autopilot tests")
    parser_list.add_argument("suite", nargs="+",
                             help="Specify test suite(s) to run.")

    parser_vis = subparsers.add_parser('vis',
                                      help="Create introspection visualisation.\
                                      Opens visualisation in xdot when not\
                                      passed an output path to write file to.")
    parser_vis.add_argument('-o', "--output", required=False,
                            help="File to write visualisation to.\
                            (Instead of opening in xdot automatically)")

    args = parser.parse_args()

    return args


def list_tests(args):
    """Print a list of tests we find inside autopilot.tests."""
    num_tests = 0
    test_suite = load_test_suite_from_name(args.suite)

    for test in iterate_tests(test_suite):
        has_scenarios = hasattr(test, "scenarios")
        if has_scenarios:
            num_tests += len(test.scenarios)
            print " *%d %s" % (len(test.scenarios), test.id())
        else:
            num_tests += 1
            print test.id()
    print "\n\n %d total tests." % (num_tests)


def run_tests(args):
    """Run tests, using input from `args`."""
    import junitxml
    import autopilot.globals

    if args.record:
        autopilot.globals.video_recording_enabled = True
        autopilot.globals.video_record_directory = args.record_directory

    test_suite = load_test_suite_from_name(args.suite)

    if args.output == None:
        results_stream = sys.stdout
    else:
        try:
            path = os.path.dirname(args.output)
            if path != '' and not os.path.exists(path):
                os.makedirs(path)
            log_file = args.output
            if os.path.isdir(log_file):
                default_log = "%s_%s.log" % (node(),
                                             datetime.now().strftime("%d.%m.%y-%H%M%S"))
                log_file = os.path.join(log_file, default_log)
                print "Using default log filename: %s " % default_log
            results_stream = open(log_file, 'w')
        except:
            results_stream = sys.stdout
    if args.format == "xml":
        result = junitxml.JUnitXmlResult(results_stream)
        result.startTestRun()
        test_suite.run(result)
        result.stopTestRun()
        results_stream.close()
        if not result.wasSuccessful:
            exit(1)
    elif args.format == "text":
        runner = TextTestRunner(stream=results_stream)
        success = runner.run(test_suite).wasSuccessful()
        if not success:
            exit(1)


def load_test_suite_from_name(test_names):
    """Returns a test suite object given a dotted test names."""
    loader = TestLoader()
    if isinstance(test_names, basestring):
        test_names = list(test_names)
    elif not isinstance(test_names, list):
        raise TypeError("test_names must be either a string or list, not %r"
                        % (type(test_names)))

    tests = []
    for test_name in test_names:
        try:
            __import__(test_name)
            tests.append(loader.discover(test_name))
        except ImportError as e:
            try:
                suite = loader.loadTestsFromName(test_name)
                if suite.countTestCases():
                    tests.append(suite)
                else:
                    print "Warning: No tests found at '%s' Loading module \
                    have error:" % (test_name)
                    print e
            except (AttributeError, ImportError) as e:
                print "Error: Cannot import test/package: %s" % e
        except KeyError as e:
            print "Warninig: Invalid test/package: %s" % e

    requested = lambda test: any([test.id().startswith(name)
                                  for name in test_names])
    selected_tests = {t.id(): t for t
                      in filter(requested, iterate_tests(TestSuite(tests)))}

    return TestSuite(selected_tests.values())


def make_visualisation(output=None):
    from autopilot.introspection.vis import get_vis_graph
    graph = get_vis_graph()
    if output:
        from os.path import splitext
        print "Writing file: %s" % output
        base, extension = splitext(output)
        write_method_name = 'write_' + extension[1:]
        write_fn = getattr(graph, write_method_name, None)
        if write_fn:
            write_fn(output)
        else:
            print "Error: unsupported format: '%s'" % (extension)
    else:
        tf = NamedTemporaryFile(suffix='.png', delete=False)
        print "Creating visualisation . . ."
        tf.write(graph.create_dot())
        tf.close()
        try:
            call(["xdot", tf.name])
        except OSError as e:
            print "Error: you need to have xdot installed to view the visualisation (%s)" % e
        remove(tf.name)


def main():
    args = parse_arguments()
    if args.mode == 'list':
        list_tests(args)
    elif args.mode == 'run':
        run_tests(args)
    elif args.mode == 'vis':
        make_visualisation(args.output)


if __name__ == "__main__":
    if not check_depends():
        exit(1)
    main()
